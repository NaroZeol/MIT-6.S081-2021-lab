# Lab: networking
## Job
为xv6提供e1000网卡驱动，一个看上去很难的工作，但实际上在hints会非常的简单。

## e1000网卡

尽管hints让我们去阅读e1000的开发者手册，但实际上课程视频中已经对要完成该lab所需的知识进行了充分的介绍（除了几个标识位的详细介绍可能没有

e1000网卡使用所谓环形缓冲区来缓存发送的和接受的数据。并且这个环形缓冲区是直接通过DMA来进行存储和读取的，也就是说驱动开发者不需要处理复杂的寄存器写入读取。只需要处理某些地址写入和读取就行了。

在逻辑上，e1000的架构（发送结构）如下所示：
```
寄存器：
                                                                                          E1000_TDBAL
                                                                                              |
                                                                                              |
环状缓冲区：                                                                                   ↓
                +--------------------------------------+--------------------------------------+
                |                   ...................|special|css|status|cmd|cso|length|addr|
                +--------------------------------------+--------------------------------------+
                                                                                        high<-low

```
在初始化时，接受环状缓冲区的每一个addr会指向一个分配好的物理空间，而发送环状缓冲区的addr会在需要发送时指定。

当发送一个数据包时，将数据包在物理内存的首地址写到`addr`，然后设置`length`为数据包的长度，设置`cmd`为`E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP`。

这时网卡就会开始工作，将数据包发送出去。

当数据包发送完毕后，网卡会将`status`位设置为`E1000_TXD_STAT_DD`，以标识当前环状缓冲区的该块处于可用状态。

当接受一个数据包时，网卡取出当前环状缓冲区指向的一个空闲的块，然后通过DMA直接向该块addr绑定的物理内存地址写入数据包。

然后产生一个中断，通知有一个数据包被接收。

## 实现e1000_transmit

基本跟着hints的指导就行了。

先通过访问`E1000_TDT`获取环状缓冲区中空闲的一个块，检查该块的state是否为`E1000_TXD_STAT_DD `来保证该块确实可用。

接着使用`mbuffress`释放上一次发送的数据包的物理内存，注意NULL检查，该数据包的位置通过`tx_mbufs`数组保存，该数组存储当前index的数据包的对应的物理内存地址。

接着设置块中的`addr`为数据包的物理内存首地址，`length`为数据包的长度，`cmd`为`E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP`。

设置`tx_mbufs`数组的当前index为发送的数据包的物理内存地址，便于下次释放。

接着更新环状缓冲区的下标即可。

## 实现e1000_receive

也是跟着hints的指导即可，不过这个会稍微复杂一些。

首先获取`E1000_RDT + 1`处的块，为什么为+1涉及到后面的实现。

总之接着检查该块的`status`位是否为`E1000_RXD_STAT_DD`，保证该块确实有数据。

`rx_mbufs`数组是一大堆指向mbuf的指针，每个指针指向当前index对应的环状缓冲区中的`addr`所对应的mbuf。但是该mbuf的len属性不会被自动设置，所以我们要手动根据块中的`length`属性来设置。

接着把这个mbuf作为参数传递给`net_rx`，这个函数会处理接收到的数据包，该mbuf的后续释放不由驱动处理。也就是说只要将该mbuf交出去后，`rx_mbufs`数组应该指向一个新的mbuf。因此我们需要调用`mbufalloc`来获取一个新的mbuf，然后更新`rx_mbufs`数组。

接着更新环状缓冲区中块的`addr`为新的mbuf的物理内存地址，`status`重置为0。

注意到在接收处理程序中是直接关闭中断的，如果实现停留在这里会导致一个问题：多个数据包同时到达却只有一个被处理。

因此我们继续检查环状缓冲区中的下一个块，看看是否有数据包到达，如果有则继续处理（这个终止条件可能会导致一些饥饿问题。。。

确保所有的数据包都被处理后，更新`E1000_RDT`即可。所以是一些小细节导致开始时的+1。

## DNS解析的一些问题
在测试的时候有一项向Google的DNS服务器发送DNS请求的测试。

神奇的是如果开着VPN，对pdos.csail.mit.edu的解析会是一个不确定的地址，而关闭VPN后就会是正确的地址（通过nslookup确认确实是正确的）。

但是关闭VPN后在QEMU里会连接不上Google的DNS服务器（🤣

总之这应该不是我的问题

## 总结

这个lab的难度在于前期的准备工作，实际的驱动实现并不复杂，因为框架代码已经完成了很多的工作，比如一看就很复杂的初始化工作。
同时hints给的提示有点过多了，基本上照着hints的步骤走就能完成该lab。

不过真正去阅读e1000的开发者手册确实是件有意思的事情。