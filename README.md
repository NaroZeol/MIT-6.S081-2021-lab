# Lab: Multithreading

## Lab: Multithreading

实现一个简易的用户态线程。其实这种要求主动放弃CPU的线程准确来说是协程。

实现一个进程最重要的就是上下文切换。

有关上下文切换的汇编代码可以kernel/swtch.S里抄。

在用户进程中，我们定义好上下文的结构体，这个结构体的定义抄自kernel/proc.h中的context结构体，同时为每一个线程分配一个自己独有的栈空间

该lab已经准备好了调度相关的代码，我们只需要实现线程的切换即可。

线程切换用的就是抄自内核的swtch函数。

最后只需完成create方法。create主要是初始化线程的上下文，这里面最大的坑就是要注意栈是从高地址向低地址增长的，所以我们不是以栈空间的低地址（首地址）来初始化sp寄存器，而是以栈空间的高地址（末地址）来初始化sp寄存器。

## Using threads

使用POSIX线程API来实现一些功能，而不是XV6。

对于POSIX线程API写的还算比较多的我来说，不算复杂的问题。

核心就是为每一个哈希桶加锁，然后再操作。

## Barrier

用POSIX API来实现一个barrier。要求所有线程都到达barrier后才能继续执行。

本质上就是一个多进程下的计数器，每个线程到达barrier后，计数器加1，然后睡眠，直到计数器等于线程数时，通过broadcast唤醒所有线程。

## 总结

除了第一题以外，这个lab设计的非常无聊。。。

只要随便看过一章并发编程的书，都能很快写出来。就算是第一题也基本上是从内核里偷代码。。。