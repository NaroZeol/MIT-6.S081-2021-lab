# Lab: Copy-on-Write Fork for xv6

## Implement copy-on write

该lab难度挺大的，前后花费了大概8个小时。

Copy-On-Write(COW)的思想就是当对一个可读可写的页面进行复制的时候，不立即进行标记，只有在某一方进行了写入时，进行真正的复制来完成写入。

核心在于将RISC-V页表项保留的其中一位作为`PTE_COW`。当一次复制发生时，清除原页表项的`PTE_W`并设置`PTE_COW`，新页表项（大概率与原页表项不在同一页表）也设置为同样的位。

当有一方发生写入时，因为`PTE_W`是被清除的，所以会发生一次缺页异常。在缺页异常中检查缺的页是不是被标记为`PTE_COW`，如果是，就进行真正的复制。

### 准备工作
查询RISC-V的手册，查看scause寄存器的说明，当触发一次缺页异常时，根据触发原因的不同，scause寄存器的值也不同。
- 12->instruction
- 13->load
- 15->store

我们要处理的是15（写入缺页），所以在`usertrap`中添加`if (scause == 15)`的处理。

### 实现简易的COW
先尝试实现一个没有引入引用计数的COW，这意味着页面永远不会被释放。

修改`uvmcopy`，删除原本要分配一个新物理页的代码。将原页表项的`PTE_W`清除，设置`PTE_COW`。新页表项映射到原页表项对应的物理页，设置相同的flags。

修改`usertrap`，在写入缺页时，检查缺页的页表项是否被标记为`PTE_COW`且是有效页，如果是，执行函数`uvmalloccopy`进行物理页的分配和复制。

因为还没有引入引用计数，所以在`uvmumap`中直接删去释放相关的代码。

这样一来一个非常糟糕的COW就实现了。

### 引入引用计数
创建一个全局的引用计数数组记录每个物理页的使用情况。当一个页被一个页表进行映射时增加引用计数，当一个页表项被删除时减少引用计数。当引用计数为0时释放物理页。

受到CSAPP的malloc lab的影响，最开始我没有选择直接在内核全局变量区保存引用计数数组（原本是打算做成动态分配），事实证明这个方案想法很美好，但是实现起来非常困难，会有各种未知的错误。

最后还是在全局变量区开了一个高达8912896字节的超大数组用来追踪所有物理页面的引用情况，很显然这个数字应该是可以优化的（但是不开这么大就会陷入莫名奇妙的kerneltrap里。。。）

总之在加入一个全局的大数组后，只需要在合适的时候增加和减少引用计数，然后在引用计数归0的时候释放物理页就可以了。

### 小心数据竞争
操作系统内核是一个大型的并发程序,像引用计数这样的东西必须要十分注意数据竞争。所以在更新引用计数和检查引用计数的时候要加锁来防止不一致的出现。

（实际上这里做的不是很好，在实现的时候`uvmumap`并没有让引用计数减一和检查引用计数是否归零以及执行`kfree`这三个操作原子化，这可能会导致一些不想要的竞争，一个更好的方案可能是引入一把大锁保平安。。。

### 修改copyout
`copyout`是用来将内核空间的数据拷贝到用户空间的。因为我们引入了COW机制，直接拷贝会有一些问题。我们需要在`copyout`中检查目标页是否是COW页。如果是则执行和`usertrap`中一样的操作来复制和分配一个新物理页。

## 总结
这个lab难度是真的大，最后的实现说实话真不能让人满意，糟糕的额外开销，糟糕的代码逻辑，糟糕的并发处理。

操作系统领域很多东西和COW一样，理念很简单，都是一听上去算是it should be那样很显然的的事情。但真正要去实现这些功能时往往会陷入无限的细节问题中。

只能说学无止境啊。。。