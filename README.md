# Lab: mmap
十分困难的一个lab，前后花费了大约九个小时来完成。

## mmap

该lab要为xv6添加一个非常常用的系统调用`mmap`，该系统调用主要涉及页表，异常处理，文件系统操作等，综合性非常强，作为最后一个lab来说非常合适。

### 添加系统调用

首先是公式化地添加系统调用，与`lab syscall`的做法一致。在此阶段，系统调用只是单纯返回失败。

### maptrack页

为了追踪一个进程到底映射了哪些页面，我们需要一个方式来记录。我选择在~~trapframe下面再开设一个maptrack页面专门用于记录这些信息。该页面由该结构体的数组组成~~（新的方案使用一个固定大小为16的数组记录）
    
```c
#define MAPTRACK_SIZE 16
struct mapentry
{
  int valid;          // is this entry valid ?
  int length;
  int prot;
  int flags;
  uint64 addr;
  struct file *f;
};
```
在精心排布好这个结构体的各个元素的位置后，一个结构体占用32字节，因此一个页面可以容纳128个结构体，因此最多能映射128个页面（感觉有点小题大做了，还不如开个小数组。。。

该结构体存储了一个映射是否有效，长度，权限，标志，映射地址，映射文件的信息。

总之完成这个页面的初始化后，我们终于有地方能够记录进程的映射信息了。

### 简易的mmap

有了可以存放映射信息的地方，现在可以开始实现一个简易的mmap。

当一个进程调用`mmap`时，我们直接从进程的堆区分配页面（通过上调进程的`sz`属性，然后再track中记录该页的信息。这样，我们就完成了一个简易的`mmap`。（在堆区直接映射会有很多问题，后续会讨论）

然后我们需要使用`filedup`来增加文件的引用计数来防止文件被关闭。

### page fault处理

接着就是实现`mmap`最重要的一部分，page fault处理。

在使用`mmap`在堆区分配一个页面后，实际上并没有改变该页面的属性，在页表中甚至都还没有该页面，该页面仍然是非法的。因此当进程尝试访问该页时就会触发page fault。在`usertrap`中，当我们在处理page fault时，通过遍历`maptrack`页面检查要访问的非法地址是否是由`mmap`映射的。如果是则尝试修复该页面。

### 修复一个页面

当确定一个页面确实是由`mmap`映射并且还没有真正变为合法的页面时，我们尝试通过`fix_page`函数来修复该页面。

因为我们保证在`mmap`时所有分配的地址都是对齐页面大小的，我们直接分配一个页面，然后计算好映射文件的偏移量，通过`readi`读到分配好的页面，随后通过`mappages`将该页面映射到进程的页表中。

映射时新页面的属性就是`maptrack`中记录的属性。

**更新**：

在新的实现中，修复页面还需要将页面修复后的物理地址写到管理页面的数组中。

### 简易的munmap

简易的`munmap`就是将`maptrack`中的记录清除，然后将页面从页表中删去，暂时我们不考虑对于标志为`MAP_SHARED`的写回文件的情况。（这里有个很显然的问题，我们没有回收堆区的空间，mmap使用的堆区空间永远不会被回收！！！）

接着使用`fileclose`来减少文件的引用计数。（也有问题。。。）

无论如何，通过以上几个实现，我们已经完成了一个简易的`mmap`。它可以通过测试f和private。

### 当前存在的问题

1. 没有处理`MAP_SHARED`的写回问题
2. 没有处理部分取消映射的情况
3. 没有回收堆区空间

### 写回

当一个页面被映射为`MAP_SHARED`时，我们需要在对该页面进行`munmap`时将该页面的更改写回文件。

我们需要注意整个`munmap`的过程都是处于内核页表下的。所以我们首先要拿到该用户页的物理地址，然后调用`writei`对文件进行写回。

注意计算好文件写入的偏移量。

### 处理部分取消映射

当我们取消映射时，并不一定一次总是取消该文件的所有页面的映射。还好该lab假设不可能使一个映射空间变得不连续，不然这个问题就很复杂了。

当取消一个映射时，我们检查取消的映射区域和已有的映射区域的关系。如果是从头开始取消，我们将track中记录的首地址向后移动并调整track中的length即可，如果是从中间开始取消，我们只需调整track中的length即可。

当确定一次取消映射会取消所有的映射时，我们才将track的vaild置为0，并且尝试关闭文件。

### 堆空间的回收

事实证明，在堆区直接映射是一个非常糟糕的主意。回收堆区的空间变得非常复杂。要如何合并，如何表示回收，如何重用空间等等问题都非常复杂。

事实上，在查阅了一些文档后[[1]](https://learnlinuxconcepts.blogspot.com/2014/03/memory-layout-of-userspace-c-program.html)，linux选择在栈和堆中间开了一片区域专门用于`mmap`，这样在管理这块专用区域时就会简单很多。

但是截止到这篇文档写作完成时，这个问题还有修复。~~（能通过测试要什么自行车）~~

**更新**： 

现在已经将这个问题修正了。新的方案在`trapframe`下面设置了16个页（只是逻辑上，实际上在真正使用前是不会分配和映射的，16或许过小，但是对于测试来说够用），并独立设置一个数组管理这些页面。当一个进程调用`mmap`时，我们直接将这些页用于`track`。当缺页发生时，修复页面并用物理地址更新管理这些页面的数组。

管理这些页面的结构体如下：

```c
struct mapstate
{
  int maped;
  int used;
  uint64 va; // address this mapstate entry correspond to
  uint64 pa; // physical address
};
```

在这些条目中，`maped`表示这个条目是否被映射到用户空间，`used`表示这个条目是否被`mmap`使用。注意两者的细微区别（被`mmap`使用不代表该页面被映射到用户空间）。`va`表示这个条目对应的用户空间地址，`pa`表示这个条目对应的物理地址。`va`是位于`trapframe`下面的几个页面之一的地址。`pa`将在缺页时被真正的更新。

当一个`mmap`被调用后，我们从这几个页中找到几个连续的且可以满足要求的页面，剩下的处理和之前几乎一样。

### 针对fork的hack

在处理完以上三个问题后，基本可以通过所有的mmaptest，但是仍然无法通过forktest。我们需要在`fork`中处理映射空间的复制问题。

首先肯定是要继承父进程的映射空间，我们直接复制父进程`maptrack`同时将每个映射文件的引用计数加一。

真正的问题在于对映射空间的拷贝，因为我们的映射空间建立在堆上，而`fork`会自动复制堆。这导致一个情况，当一个页面被映射（堆指针被上调）后，`fork`会复制这个页面，但是如果这个页面还没有被访问过。也就是该页面事实上并不是一个合法的页面，但是却被复制了。

这个问题的来源就在于选择用堆来进行映射。在重构这个糟糕的结构之前，我们hack掉`uvmcopy`和`uvmunmap`中检查一个页面是否合法的流程。虽然这个hack非常不优雅，但是确实使我们通过了所有的测试。

**更新**：

后续将映射空间从堆中独立后，这个问题也得到了解决。
### exit的处理

最后一个问题就是`exit`的处理。我们需要在`exit`时处理所有的映射空间。就是照搬`munmap`的逻辑，将所有的映射空间取消。

## 总结

经典的理论一看就懂，实践一碰就碎。

这个lab的难度在于它涉及到了非常多的知识点，页表，异常处理，文件系统等等。

尽管mmap的理论真的是很显然很好理解，但是在实践中却有很多细节问题需要处理。或许这就是操作系统的魅力吧。

这个lab中选择了很多不合适的方案，比如过多的maptrack，直接在堆上映射，没有处理exit，擅自更改了uvmcopy等等。这些都是不合适的做法，很多是为了通过测试而进行的dirty hack。后续如果有时间，我会尝试重构这个lab，使其更加合理。（希望能不鸽🕊

真是学无止境啊。。。
