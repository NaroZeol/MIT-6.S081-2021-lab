# Lab: file system
## Large files
为xv6提供大文件支持。

在修改前xv6使用12个直接指针和1个一级间接指针。一级间接指针指向一个大小为1024字节的块，块中存有1024/4=256个直接指针。

要为xv6提供大文件支持，我们需要为其添加一个二级间接指针，二级间接指针指向一个包含256个一级间接指针的块，然后每个一级间接指针再指向包含256个直接指针的块。

首先修改inode的结构，其实没有真正地改变inode的结构。原先的结果由12+1的指针组成，现在只不过是变为11+1+1的结构，只是逻辑上的改变。总之修改`NDIRECT`，添加`NDOUBLEINDIRECT`为`(NINDERECT * NINDIRECT)`。

接着根据hints修改`bmap`，观察该函数原有结构，原有结构后面添加当`bn`大于`NDIRECT + NINDIRECT`时的情况，即要使用二级间接指针时的情况。

首先检查二级间接指针指向的块是否已经分配，如果没有分配则为其分配一个。

接着根据数学关系计算出在二级间接指针指向的块中，需要使用的一级间接指针的位置（`bn / NINDIRECT`），然后检查该一级间接指针指向的块是否已经分配，如果没有分配则为其分配一个，同时记录日志。

接着根据数学关系计算出在一级间接指针指向的块中，需要使用的直接指针的位置（`bn % NINDIRECT`），然后检查该直接指针是否已经分配，如果没有分配则为其分配一个，同时记录日志。

最后返回直接指针的指向的块的块号（该函数中`addr`代指的是块号）。

最后按照hints修改`itrunc`，即销毁一个文件。其实就是和`bmap`操作一样，只不过最后的行为是释放块而不是分配块。

先检查是否有二级间接指针，如果有则开始遍历二级间接指针指向的块上的一级间接指针，如果该一级间接指针有效，则遍历该一级间接指针指向的块，释放其中的直接指针。

## Symbolic links
为xv6添加符号链接支持。

符号链接是一种特殊的文件，其内容是一个路径名。当访问符号链接时，内核会将路径名解析为一个文件，并尝试打开该文件。

总的来说就是一个类似于快捷方式的东西。

这里有一个小hack，inode中各级指针总共有13个，每个指针大小为4字节，也就是说如果一个路径名小于52字节，那么可以直接存储在inode原本放各级指针数据的地方，不需要额外分配一个最多只能使用128/1024的块。（这个hack是因为之前把最大路径的128字节误认成了128bits，所以才会有这个hack，但还好测试中的路径名都不超过52字节，更好的做法是进行一次判断，如果小于52字节则直接放在inode中，如果高于52字节则分配一个数据块来存储）

下面的讲述都建立在这个hack没有问题的前提下。

首先添加系统调用和相关宏，这个比较公式化，参考`lab syscall`里面做法即可。

在`sys_symlink`中，使用`begin_op`和`end_op`来保证对文件系统操作的原子性，然后通过`create`来创建一个新文件，在创建时指定文件类型为`T_SYMLINK`。接着根据hack，将`ip->addrs`直接作为路径名存储位置，将路径名拷贝到`ip->addrs`中。这样一个符号链接文件就创建好了。

接着就是要修改`sys_open`来使用符号链接的代理功能。当检查到要打开的文件是一个符号链接时，调用`symlink_walk`来解析这个符号链接。

`symlink_walk`函数根据存储在`ip->addrs`中的路径名，调用`namei`来获取路径名对应的inode。如果获取到的文件仍然是一个符号链接，则继续解析。在过程中使用一个固定大小的数组`trace`来存储已经解析过的符号链接来保证不会出现环状解析以及限制最大解析深度。但获取到的文件不是一个符号链接时，返回该文件的inode，这样就实现了对一个文件的代理访问。

hints说当对一个符号链接文件调用`unlink`时只需释放该符号链接文件即可。注意因为我们对`addr`进行了hack，如果就这么释放的话，在调用`itrunc`时会导致不该被释放的数据块被释放。所以在确定要`unlink`一个符号链接文件时，将`ip->addrs`清零。

## 总结

这两个实验都是moderate级别的。难度不大。只要理解xv6文件系统的基本构造就行。

但xv6的文件系统远比这两个实验中感受到的要复杂，就算xv6只有一个很简单的文件系统。

这两个实验没有涉及我更在意的进程文件表与文件描述符，如何与磁盘的交互等更有意思的话题。毕竟框架代码把这些都做的太好了。