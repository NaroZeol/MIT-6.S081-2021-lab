# Lab: traps

## RISC-V assembly

一些小问题。

我没有完整学过RISC-V的汇编，只会一点简单的X86汇编。但还好两者有很多相似之处。

两者汇编我目前觉得最大的区别就在于函数返回地址的处理上。

X86是直接用栈来保存返回地址的，而RISC-V则是用寄存器来保存返回地址的。

感觉其实是因为RISC-V把X86的工作细分了一下。

X86函数返回：从栈顶取出返回地址 -> 跳转到该地址

RISC-V函数返回：取出返回地址->放置到某个寄存器->跳转到该寄存器对应的地址

RISC-V把返回的寄存器暴露了出来，其他好像没有啥区别。

## Backtrace 

实现一个打印调用堆栈的函数。

根据hints，gcc编译后的代码的栈帧会组织成以下形式

```
High Address (PGROUNDUP)
        +----------------+<--------┐
8bytes->| Return Address |         |
        | To Pre Frame   |         |
        | Saved Regs     |         |
        | ........       |<---┐    |
        |----------------|    |    |
        | Return Address |----┛    |
        | To Pre Frame   |---------┛
        | Saved Regs     |
        | ........       |

Low Address (PGROUNDDOWN)
```
如果获取到了当前的栈帧首地址fp，那么fp-8开始的8个字节就是返回地址，fp-16开始的8个字节就是上一个栈帧的首地址。（注意栈是从高地址向低地址增长的，fp处于高位）

栈的组织类似于链表，我们使用类似链表的方式来向上遍历栈帧，直到遍历到终点。

问题在于终点是什么，我们要上溯的是在内核态发生的事情，每一个进程都有自己独有的内核栈，并且内核栈的大小就是一页并且地址是向页大小对齐。

所以终点就是离开内核栈之前的那个栈帧。

首先我们先用`PGROUNDDOWN`来确定当前内核栈的位置并存储起来，while循环检查当前栈帧的`PGROUNDDOWN`是否等于之前存储的`PGROUNDDOWN`，如果相等则说明我们仍然位于内核栈中，否则说明我们已经离开内核栈。

## Alarm 

实现一个alarm函数，当时间到达时，调用一个函数。

这个lab的最大难题在于用户态和内核态的切换上。

当一个时钟中断触发时，理想的逻辑流会是这样：

1. 时钟中断触发，切换到内核态（用户态1）
2. 时钟中断处理函数检查是否满足跳转条件，如果满足则准备切换到用户态并且跳转到handler函数（内核态2）
3. handler函数执行并在要完成时显式调用sigreturn，切换回内核态（用户态3）
4. sigreturn系统调用重新设置寄存器，恢复到时钟中断发生前的状态（内核态4）
5. sigreturn完成后继续执行用户态代码（用户态5）

流程中会发生**用户->内核->用户->内核->用户**的切换，每一次切换都要保证寄存器的正确性。

下面分析各个内核态下，`trapframe`的所持有的信息：
    
- 内核态2：在这个状态下，`trapframe`保存有时钟中断发生前的寄存器状态。
- 内核态4：在该状态内，`trapframe`保存有handler函数返回前的寄存器状态，大概率不和内核态2的`trapframe`一致。

当返回到用户态时，所有寄存器的期望状态：
- 用户态1：该状态不由内核返回
- 用户态3：该状态由内核返回，但由于`handler`函数是无参数的函数，所以它也不期望任何寄存器的状态
- 用户态5：该状态将从时钟中断发生前的状态继续执行，所以所有寄存器的状态都应该和时钟中断发生前的状态一致，即与内核态2的`trapframe`一致。

通过以上分析，因为handler函数可能会修改一些寄存器，所以前后两个内核态的`trapframe`大概率是不同的，因此我们需要保存内核态2的`trapframe`，并在切换到用户态5时，将`trapframe`中的寄存器状态恢复到寄存器中。

所以我在每个进程`trapframe`下面再添加了一项`alarmframe`用于暂存内核态2的`trapframe`。

在内核态2中，在保存完当前的`trapframe`后修改其中的`epc`为handler函数的地址，然后将调用`usertrapret`就可以跳转到正确的用户态3。

当handler函数执行完毕后，调用`sigreturn`系统调用，将`alarmframe`中保存的信息复制给`trapframe`，然后调用`usertrapret`就可以跳转到用户态5，即时钟中断发生前的状态。

至于怎么注册handler函数的那些细节就不再赘述了。

## 总结

这个lab还是很有意思的，真正深入到了操作系统内核的实现，不再局限于用户态的应用程序。这才是真正的dive into。

不同状态的处理以及寄存器的保存和恢复都是这个lab的难点，但也是这个lab的精髓所在。