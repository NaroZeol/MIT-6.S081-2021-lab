# Lab: page tables
## Speed up system calls
实现所谓的非陷入内核系统调用。

核心思想是在`trapframe`下面再加一页`usyscall`，该页存放只读的进程相关数据，比如进程号pid，这样用户程序就能在不陷入内核的情况下完成系统调用。

修改`struct proc`，为其增加一个指向`usyscall`的指针。同时照搬`trapframe`的初始化和销毁方式，并在创建进程时将进程的pid赋值给`usyscall->pid`。不过要注意`usyscall`页要被设置成用户只读。

## Print a page table

xv6使用的是三级页表

一级页表中记录着各个二级页表的物理地址，二级页表中记录着各个三级页表的物理地址，三级页表中记录着各个页的物理地址。

当一个页表项的`PTE_V`被置一但是`PTE_W` `PTE_R` `PTE_X`没有一个被置一。则认为该页表项是一个间接页表项，其内容是下一级页表的物理地址。

根据以上信息我们就可以实现`vmprint`。首先遍历一级页表，也就是当前进程的`pagetable`所对应的页表。

检查一级页表中的每一项，如果有满足`PTE_V`置一而其他位都不置一的页表项，那么这个页表项就是一个二级页表项。

接着重复和一级页表遍历相同的工作即可实现打印该进程的所有页表信息。

最后的实现写的有点抽象，毕竟我不打算引入新的递归函数。

## Detecting which pages have been accessed

该实验要求利用risc-v页表提供的`PTE_A`位来检测哪些页被访问过。

`walk`函数是实现这个功能的关键。

它返回一个虚拟地址对应的PTE的物理地址。通过这个函数我们从给定的基址开始，按页遍历整个虚拟地址空间，检查每个页表项的`PTE_A`位。如果`PTE_A`位被置一，那么说明这个页被访问过，我们将mask中的对应位置一，并且将这个页表项的`PTE_A`位清零。

整个操作都是在页表寄存器指向内核页表时进行的，对内存的访问只会导致内核页表中某些条目的`PTE_A`被置一而不会影响用户页表中的任何内容。所以不需要在意是否使用`walk`函数会导致用户页表项的`PTE_A`位被置一。

## 总结

这个lab有一点的难度，需要对页表的知识有足够深的掌握。

该lab有意引导学生去照搬xv6的相关实现，但是要找到正确的xv6实现也确实不容易。

现代的IDE都带有引用查询功能，在这个lab中，使用该功能追踪`trapframe`的初始化和销毁对第一个实验很有帮助。

第二个实验主要是去参考`walk`的实现，明白多级页表是怎么实现的。

第三个实验的难点在于如何分清内核页表和用户页表，以及如何在内核页表中访问用户页表。